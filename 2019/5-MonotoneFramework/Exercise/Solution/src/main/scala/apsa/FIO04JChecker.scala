/* BSD 2-Clause License - see OPAL/LICENSE for details. */
package apsa

import java.net.URL

import java.util.concurrent.ConcurrentLinkedQueue

import scala.collection.JavaConverters._

import org.opalj.value.ValueInformation
import org.opalj.br._
import org.opalj.br.analyses._
import org.opalj.br.instructions._
import org.opalj.br.MethodDescriptor.JustTakes
import org.opalj.br.MethodDescriptor.NoArgsAndReturnVoid
import org.opalj.ai.domain.l1.DefaultDomainWithCFGAndDefUse
import org.opalj.tac.ComputeTACAIKey
import org.opalj.tac.TACode
import org.opalj.tac.Stmt
import org.opalj.tac.DUVar
import org.opalj.tac.VirtualFunctionCall
import org.opalj.tac.AssignmentLikeStmt
import org.opalj.tac.New
import org.opalj.tac.Assignment
import org.opalj.tac.NonVirtualMethodCall
import org.opalj.tac.Assignment
import org.opalj.tac.Const
import org.opalj.collection.immutable.IntTrieSet
import org.opalj.br.cfg.CFG
import org.opalj.tac.VirtualMethodCall
import org.opalj.tac.If
import org.opalj.tac.NullExpr
import org.opalj.tac.PutField
import org.opalj.tac.PutStatic
import org.opalj.tac.DefSites
import org.opalj.tac.ReturnValue
import org.opalj.tac.ToTxt

object FIO04JChecker extends ProjectAnalysisApplication {

  override def description: String = "Finds violations of FIO04-J"

  def doAnalyze(p: Project[URL], params: Seq[String], isInterrupted: () ⇒ Boolean): BasicReport = {

    val ch = p.classHierarchy

    p.updateProjectInformationKeyInitializationData(ComputeTACAIKey) { _ ⇒ (m: Method) ⇒
      new DefaultDomainWithCFGAndDefUse(p, m)
    }
    val tacaiProvider = p.get(ComputeTACAIKey)

    val bugs = new ConcurrentLinkedQueue[String]()

    val AutoCloseableType = Type(classOf[AutoCloseable]).asObjectType

    p.parForeachMethodWithBody(isInterrupted) { mi ⇒
      val m = mi.method
      val taCode = tacaiProvider(m)
      val stmts = taCode.stmts
      val cfg = taCode.cfg
      // Fact: The pair consisting of:
      //       (1) the set of def-sites (the `new` instruction) of initialized resources
      //           I.e., objects on which an <init> call has happened.
      //           (Let's ignore that we could have mulitple <init> calls on different paths,
      //           because such code is not generated by standard compilers.)
      //       (2) the returned (and not closed) closeables.
      type Facts = ( /*initialized, but not yet closed*/ IntTrieSet, /*returned*/ IntTrieSet)
      val seed: Facts = (IntTrieSet.empty, IntTrieSet.empty)

      def transfer(
          inFacts: Facts,
          stmt: Stmt[DUVar[ValueInformation]],
          index: PC,
          succId: CFG.SuccessorId
      ): Facts = {
        stmt match {
          case NonVirtualMethodCall(_, declaringClass, _, "<init>", _, receiver, _)
              if (
                ch.isSubtypeOf(declaringClass, AutoCloseableType) &&
                  // The resources must only be closed if the initializer didn't trow
                  // an exception:
                  succId >= 0 &&
                  // Do not consider calls of the super constructor of a resource or
                  // where the resources was given as a parameter:
                  receiver.asVar.definedBy.forall(_ >= 0)
              ) ⇒
            val (notClosed, returned) = inFacts
            (notClosed ++ receiver.asVar.definedBy, returned)

          // Let's forget about those resources that are stored in fields:
          case PutField(_, _, _, _, _, DefSites(defSites)) ⇒
            val (notClosed, returned) = inFacts
            (notClosed -- defSites, returned)

          case PutStatic(_, _, _, _, DefSites(defSites)) ⇒
            val (notClosed, returned) = inFacts
            (notClosed -- defSites, returned)

          // TODO Let's forget resources passed to other methods ...

          // Let's forget about those resources that are returned:
          case ReturnValue(_, DefSites(defSites)) ⇒
            val (notClosed, returned) = inFacts
            (notClosed -- defSites, returned ++ defSites)

          case VirtualMethodCall(_, _, _, "close", NoArgsAndReturnVoid, receiver, _) ⇒
            val (notClosed, returned) = inFacts
            (notClosed -- receiver.asVar.definedBy, returned)

          case _ ⇒ inFacts
        }
      }

      // Only those resources are closed that are closed on all paths; i.e.,
      // if a resource is not closed on all paths, we keep it.
      def join(oldFacts: Facts, newFacts: Facts): Facts = {
        val (oldNotClosed, oldReturned) = oldFacts
        val (newNotClosed, newReturned) = newFacts
        val joinedNotClosed = oldNotClosed ++ newNotClosed
        val joinedReturned = oldReturned ++ newReturned
        if (joinedNotClosed.size > oldNotClosed.size || joinedReturned.size > oldReturned.size)
          (joinedNotClosed, joinedReturned)
        else
          oldFacts
      }

      val (_, unclosedR, unclosedE) = cfg.performForwardDataFlowAnalysis(seed, transfer, join)
      var allUnclosed = IntTrieSet.empty
      var allReturned = IntTrieSet.empty
      if (unclosedR ne null) {
        val (notClosed, returned) = unclosedR
        allUnclosed ++= notClosed
        allReturned ++= returned
      }
      if (unclosedE ne null) {
        val (notClosed, returned) = unclosedE
        allUnclosed ++= notClosed
        allReturned ++= returned
      }
      var unclosedAndNotReturned = allUnclosed -- allReturned
      if (unclosedAndNotReturned.nonEmpty) {
        var msg = m.toJava(unclosedAndNotReturned.mkString("Unclosed resources: {", ", ", "}"))
        // To get more information:
        msg += "\n" + ToTxt(taCode).mkString("\n")
        bugs.add(msg)
      }
    }

    bugs.asScala.toList.sorted.mkString("\n")
  }
}
